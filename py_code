
import pandas as pd #biblioteca para manupulacao de dados
from unidecode import unidecode #edicao de caracteres
import matplotlib.pyplot as plt #plotagem de graficos
import seaborn as sns #biblioteca com base no matplotlib com melhor design para plotagem
import numpy as np #operacoes com array, validacoes cruzadas

from sklearn.preprocessing import StandardScaler # Pré Processamento - biblioteca para normalizacao de caracteristicas/categorias
from sklearn.preprocessing import MinMaxScaler # Pré Processamento - biblioteca para normalizacao de dados
from sklearn.preprocessing import LabelEncoder # Pré Processamento - biblioteca para converter rotulos das categorias em rotulos numericos
from sklearn.model_selection import train_test_split, cross_val_score # Bibliotecas Scikit-learn para ML, teste e treinamento e Biblioteca para realizar validacao cruzada nos modelos de ML
from sklearn.metrics import classification_report, accuracy_score # Biblioteca Scikit-learn para ML, avaliacao dos modelos
from sklearn.metrics import mean_squared_error, mean_absolute_error # Aplicação de metricas Mean Squared Error (MSE) e Mean Absolute Error (MAE)

'''Dados de Julho de 2023'''

#Ler arquivo .csv, gerando datafreame
df23 = pd.read_csv("d_frota_por_uf_municipio_combustivel_julho_2023.csv",
                         encoding = "UTF-8", sep = ";", usecols = ["UF",'Municipio',"Combustivel Veiculo","Qtd. Veiculos"])

print(df23.info()) #Qtd de entradas de dados = 47601
print(df23.head()) #Mostrar 5 primeiras linhas da tabela

#Substituir espacos (onde houver) dos titulos das colunas por "_"
df23.columns = df23.columns.str.replace(' ', '_')
print(df23.head())

print(df23['UF'].unique())
#Remover acentos e trocar espacos por "_" das linhas da coluna 'UF'
df23['UF'] = df23['UF'].apply(unidecode).str.replace(' ', '_')
#Deletar dados da coluna 'UF' sem identificacao de estados
df23 = df23[~df23['UF'].isin(['Nao_Identificado', 'Nao_se_Aplica', 'Sem_Informacao'])]
print(df23['UF'].unique())

print(df23['Combustivel_Veiculo'].unique())
#Remover acentos e trocar espa�os por "_" das linhas da coluna 'Combustivel_Veiculo'
df23['Combustivel_Veiculo'] = df23['Combustivel_Veiculo'].apply(unidecode).str.replace(' ', '_')
#Deletar dados da coluna 'Combustivel_Veiculo' sem identificacao de tipo de combustivel
df23 = df23[~df23['Combustivel_Veiculo'].isin(['Nao_Identificado', 'Sem_Informacao', 'VIDE/CAMPO/OBSERVACAO'])]
print(df23['Combustivel_Veiculo'].unique())

print(df23['Municipio'].unique())
#Remover acentos e trocar espacos por "_" das linhas da coluna 'Municipio'
df23['Municipio'] = df23['Municipio'].apply(unidecode).str.replace(' ', '_')
print(df23['Municipio'].unique())

#Reagrupamento de veiculos Hibridos Completos (HEV) e Hibridos Leves (MHEV), com excessao dos Hibridos Plugin (PHEV): HIBRIDO
#Veiculos Flex, Gasolina, Alcool, GNV, Diesel (nao eletrificados), serao reagrupados como "COMBUSTAO"
#Veiculos 100% eletricos (BEV) adicionados ao novo agrupamento: ELETRICO
HIBRIDO = ['GASOLINA/ALCOOL/ELETRICO', 'GASOLINA/ELETRICO', 'DIESEL/ELETRICO', 'HIBRIDO', 'ETANOL/ELETRICO']
COMBUSTAO = ['ALCOOL', 'ALCOOL/GASOLINA', 'DIESEL', 'GASOLINA', 'GASOLINA/ALCOOL/GAS_NATURAL', 'GASOL/GAS_NATURAL_COMBUSTIVEL', 'GASOLINA/GAS_NATURAL_VEICULAR', 'ALCOOL/GAS_NATURAL_COMBUSTIVEL', 'ALCOOL/GAS_NATURAL_VEICULAR', 'GAS_METANO', 'GAS_NATURAL_VEICULAR', 'GASOGENIO', 'DIESEL/GAS_NATURAL_VEICULAR', 'DIESEL/GAS_NATURAL_COMBUSTIVEL', 'GAS/NATURAL/LIQUEFEITO']
ELETRICO = ['ELETRICO/FONTE_EXTERNA', 'ELETRICO/FONTE_INTERNA', 'ELETRICO']
df23['Combustivel_Veiculo'] = df23['Combustivel_Veiculo'].apply(lambda x: 'HIBRIDO' if x in HIBRIDO else x)
df23['Combustivel_Veiculo'] = df23['Combustivel_Veiculo'].apply(lambda x: 'COMBUSTAO' if x in COMBUSTAO else x)
df23['Combustivel_Veiculo'] = df23['Combustivel_Veiculo'].apply(lambda x: 'ELETRICO' if x in ELETRICO else x)
print(df23['Combustivel_Veiculo'].unique())
#Para melhorar a visualizacao e evitar a repeticao dos nomes dos combustiveis, o agrupamento sera feito atraves do comando groupby() com somatoria dos valores
df23 = df23.groupby(['UF', 'Municipio', 'Combustivel_Veiculo']).sum().reset_index()

#df23.to_csv('df23_tratado.csv', index=False) #criar novo arquivo do dataframe
print(df23) 

''' Dados de Julho de 2022'''

df22 = pd.read_csv("d_frota_por_uf_municipio_combustivel_julho_2022.csv",
                         encoding = "UTF-8", sep = ";", usecols = ["UF",'Municipio',"Combustivel Veiculo","Qtd. Veiculos"])

# Substituir espacos (onde houver) dos titulos das colunas por "_"
df22.columns = df22.columns.str.replace(' ', '_')
# Tratamento das colunas: remocao de acentos, troca de espacos por "_" e filtragem de dados sem info
df22['UF'] = df22['UF'].apply(unidecode).str.replace(' ', '_')
df22 = df22[~df22['UF'].isin(['Nao_Identificado', 'Nao_se_Aplica', 'Sem_Informacao'])]

df22['Combustivel_Veiculo'] = df22['Combustivel_Veiculo'].apply(unidecode).str.replace(' ', '_')
df22 = df22[~df22['Combustivel_Veiculo'].isin(['Nao_Identificado', 'Sem_Informacao', 'VIDE/CAMPO/OBSERVACAO'])]

df22['Municipio'] = df22['Municipio'].apply(unidecode).str.replace(' ', '_')

# Reagrupamento de veiculos Hibridos(exceto PHEV), a Combustao e Eletricos
HIBRIDO = ['GASOLINA/ALCOOL/ELETRICO', 'GASOLINA/ELETRICO', 'DIESEL/ELETRICO', 'HIBRIDO', 'ETANOL/ELETRICO']
COMBUSTAO = ['ALCOOL', 'ALCOOL/GASOLINA', 'DIESEL', 'GASOLINA', 'GASOLINA/ALCOOL/GAS_NATURAL', 'GASOL/GAS_NATURAL_COMBUSTIVEL', 'GASOLINA/GAS_NATURAL_VEICULAR', 'ALCOOL/GAS_NATURAL_COMBUSTIVEL', 'ALCOOL/GAS_NATURAL_VEICULAR', 'GAS_METANO', 'GAS_NATURAL_VEICULAR', 'GASOGENIO', 'DIESEL/GAS_NATURAL_VEICULAR', 'DIESEL/GAS_NATURAL_COMBUSTIVEL', 'GAS/NATURAL/LIQUEFEITO']
ELETRICO = ['ELETRICO/FONTE_EXTERNA', 'ELETRICO/FONTE_INTERNA', 'ELETRICO']
df22['Combustivel_Veiculo'] = df22['Combustivel_Veiculo'].apply(lambda x: 'HIBRIDO' if x in HIBRIDO else x)
df22['Combustivel_Veiculo'] = df22['Combustivel_Veiculo'].apply(lambda x: 'COMBUSTAO' if x in COMBUSTAO else x)
df22['Combustivel_Veiculo'] = df22['Combustivel_Veiculo'].apply(lambda x: 'ELETRICO' if x in ELETRICO else x)
print(df22['Combustivel_Veiculo'].unique())
# Para melhorar a visualizacao e evitar a repeticao dos nomes dos combustiveis, o agrupamento sera feito atraves do comando groupby() com somatoria dos valores
df22 = df22.groupby(['UF', 'Municipio', 'Combustivel_Veiculo']).sum().reset_index()

print(df22) 

''' Dados de Julho de 2021'''

# Carregar os dados
df21 = pd.read_csv("d_frota_por_uf_municipio_combustivel_julho_2021.csv",
                   encoding="UTF-8", sep=";", usecols = ["UF",'Municipio',"Combustivel Veiculo","Qtd. Veiculos"])

# Substituir espacos (onde houver) dos titulos das colunas por "_"
df21.columns = df21.columns.str.replace(' ', '_')
# Tratamento das colunas: remocao de acentos, troca de espacos por "_" e filtragem de dados sem info
df21['UF'] = df21['UF'].apply(unidecode).str.replace(' ', '_')
df21 = df21[~df21['UF'].isin(['Nao_Identificado', 'Nao_se_Aplica', 'Sem_Informacao'])]

df21['Combustivel_Veiculo'] = df21['Combustivel_Veiculo'].apply(unidecode).str.replace(' ', '_')
df21 = df21[~df21['Combustivel_Veiculo'].isin(['Nao_Identificado', 'Sem_Informacao', 'VIDE/CAMPO/OBSERVACAO'])]

df21['Municipio'] = df21['Municipio'].apply(unidecode).str.replace(' ', '_')

# Reagrupamento de veiculos Hibridos, a Combustao e Eletricos
HIBRIDO = ['GASOLINA/ALCOOL/ELETRICO', 'GASOLINA/ELETRICO', 'DIESEL/ELETRICO', 'HIBRIDO', 'ETANOL/ELETRICO']
COMBUSTAO = ['ALCOOL', 'ALCOOL/GASOLINA', 'DIESEL', 'GASOLINA', 'GASOLINA/ALCOOL/GAS_NATURAL', 'GASOL/GAS_NATURAL_COMBUSTIVEL', 'GASOLINA/GAS_NATURAL_VEICULAR', 'ALCOOL/GAS_NATURAL_COMBUSTIVEL', 'ALCOOL/GAS_NATURAL_VEICULAR', 'GAS_METANO', 'GAS_NATURAL_VEICULAR', 'GASOGENIO', 'DIESEL/GAS_NATURAL_VEICULAR', 'DIESEL/GAS_NATURAL_COMBUSTIVEL', 'GAS/NATURAL/LIQUEFEITO']
ELETRICO = ['ELETRICO/FONTE_EXTERNA', 'ELETRICO/FONTE_INTERNA', 'ELETRICO']
df21['Combustivel_Veiculo'] = df21['Combustivel_Veiculo'].apply(lambda x: 'HIBRIDO' if x in HIBRIDO else x)
df21['Combustivel_Veiculo'] = df21['Combustivel_Veiculo'].apply(lambda x: 'COMBUSTAO' if x in COMBUSTAO else x)
df21['Combustivel_Veiculo'] = df21['Combustivel_Veiculo'].apply(lambda x: 'ELETRICO' if x in ELETRICO else x)
print(df21['Combustivel_Veiculo'].unique())

# Para melhorar a visualizacao e evitar a repeticao dos nomes dos combustiveis, o agrupamento sera feito atraves do comando groupby() com somatoria dos valores
df21 = df21.groupby(['UF', 'Municipio', 'Combustivel_Veiculo']).sum().reset_index()

print(df21)

'''Dados de Julho de 2020'''

df20 = pd.read_csv("d_frota_por_uf_municipio_combustivel_julho_2020.csv",
                   encoding="UTF-8", sep=";", usecols = ["UF",'Municipio',"Combustivel Veiculo","Qtd. Veiculos"])

# Substituir espacos dos titulos das colunas por "_"
df20.columns = df20.columns.str.replace(' ', '_')
# Tratamento das colunas: remocao de acentos, troca de espacos por "_" e filtragem de dados sem info
df20[['UF', 'Municipio', 'Combustivel_Veiculo']] = df20[['UF', 'Municipio', 'Combustivel_Veiculo']].applymap(unidecode).applymap(lambda x: x.replace(' ', '_'))
df20 = df20[~df20['UF'].isin(['Nao_Identificado', 'Nao_se_Aplica', 'Sem_Informacao'])]
df20 = df20[~df20['Combustivel_Veiculo'].isin(['Nao_Identificado', 'Sem_Informacao', 'VIDE/CAMPO/OBSERVACAO'])]

# Reagrupamento de veiculos Hibridos, a Combustao e Eletricos
df20['Combustivel_Veiculo'] = df20['Combustivel_Veiculo'].apply(lambda x: 'HIBRIDO' if x in HIBRIDO else x)
df20['Combustivel_Veiculo'] = df20['Combustivel_Veiculo'].apply(lambda x: 'COMBUSTAO' if x in COMBUSTAO else x)
df20['Combustivel_Veiculo'] = df20['Combustivel_Veiculo'].apply(lambda x: 'ELETRICO' if x in ELETRICO else x)
print(df20['Combustivel_Veiculo'].unique())

# Agrupamento atraves do comando groupby() com somatoria dos valores
df20 = df20.groupby(['UF', 'Municipio', 'Combustivel_Veiculo']).sum().reset_index()

print(df20)

'''Dados de Julho de 2019'''

df19 = pd.read_csv("d_frota_por_uf_municipio_combustivel_julho_2019.csv",
                   encoding="UTF-8", sep=";", usecols = ["UF",'Municipio',"Combustivel Veiculo","Qtd. Veiculos"])

# Substituir espacos dos titulos das colunas por "_"
df19.columns = df19.columns.str.replace(' ', '_')
# Tratamento das colunas: remocao de acentos, troca de espacos por "_" e filtragem de dados sem info
df19[['UF', 'Municipio', 'Combustivel_Veiculo']] = df19[['UF', 'Municipio', 'Combustivel_Veiculo']].applymap(unidecode).applymap(lambda x: x.replace(' ', '_'))
df19 = df19[~df19['UF'].isin(['Nao_Identificado', 'Nao_se_Aplica', 'Sem_Informacao'])]
df19 = df19[~df19['Combustivel_Veiculo'].isin(['VIDE/CAMPO/OBSERVACAO', 'NAPSo_se_Aplica', 'NAPSo_Identificado', 'Sem_InformaASSAPSo'])]

# Reagrupamento de veiculos Hibridos, a Combustao e Eletricos
HIBRIDO = ['GASOLINA/ALCOOL/ELETRICO', 'GASOLINA/ELETRICO', 'DIESEL/ELETRICO', 'HIBRIDO', 'ETANOL/ELETRICO']
COMBUSTAO = ['ALCOOL', 'ALCOOL/GASOLINA', 'DIESEL', 'GASOLINA', 'GASOLINA/ALCOOL/GAS_NATURAL', 'GASOL/GAS_NATURAL_COMBUSTIVEL', 'GASOLINA/GAS_NATURAL_VEICULAR', 'ALCOOL/GAS_NATURAL_COMBUSTIVEL', 'ALCOOL/GAS_NATURAL_VEICULAR', 'GAS_METANO', 'GAS_NATURAL_VEICULAR', 'GASOGENIO', 'DIESEL/GAS_NATURAL_VEICULAR', 'DIESEL/GAS_NATURAL_COMBUSTIVEL', 'GAS/NATURAL/LIQUEFEITO']
ELETRICO = ['ELETRICO/FONTE_EXTERNA', 'ELETRICO/FONTE_INTERNA', 'ELETRICO']

df19['Combustivel_Veiculo'] = df19['Combustivel_Veiculo'].apply(lambda x: 'HIBRIDO' if x in HIBRIDO else x)
df19['Combustivel_Veiculo'] = df19['Combustivel_Veiculo'].apply(lambda x: 'COMBUSTAO' if x in COMBUSTAO else x)
df19['Combustivel_Veiculo'] = df19['Combustivel_Veiculo'].apply(lambda x: 'ELETRICO' if x in ELETRICO else x)
print(df19['Combustivel_Veiculo'].unique())

# Agrupamento atraves do comando groupby() com somatoria dos valores
df19 = df19.groupby(['UF', 'Municipio', 'Combustivel_Veiculo']).sum().reset_index()

print(df19)

'''Dados de Julho de 2018'''

import pandas as pd
from unidecode import unidecode

''' Dados de Julho de 2018'''

# Carregar os dados
df18 = pd.read_csv("d_frota_por_uf_municipio_combustivel_julho_2018.csv",
                   encoding="UTF-8", sep=";", usecols=["UF", 'Municipio', "Combustivel Veiculo", "Qtd. Veiculos"])

# Substituir espacos (onde houver) dos titulos das colunas por "_"
df18.columns = df18.columns.str.replace(' ', '_')

# Tratamento das colunas: remocao de acentos, troca de espacos por "_" e filtragem de dados sem info
df18[['UF', 'Municipio', 'Combustivel_Veiculo']] = df18[['UF', 'Municipio', 'Combustivel_Veiculo']].applymap(unidecode).applymap(lambda x: x.replace(' ', '_'))
df18 = df18[~df18['UF'].isin(['Nao_Identificado', 'Nao_se_Aplica', 'Sem_Informacao'])]
df18 = df18[~df18['Combustivel_Veiculo'].isin(['VIDE/CAMPO/OBSERVACAO', 'NAPSo_se_Aplica', 'NAPSo_Identificado', 'Sem_InformaASSAPSo'])]

# Reagrupamento de veiculos Hibridos(exceto PHEV), a Combustao e Eletricos
HIBRIDO = ['GASOLINA/ALCOOL/ELETRICO', 'GASOLINA/ELETRICO', 'DIESEL/ELETRICO', 'HIBRIDO', 'ETANOL/ELETRICO']
COMBUSTAO = ['ALCOOL', 'ALCOOL/GASOLINA', 'DIESEL', 'GASOLINA', 'GASOLINA/ALCOOL/GAS_NATURAL', 'GASOL/GAS_NATURAL_COMBUSTIVEL', 'GASOLINA/GAS_NATURAL_VEICULAR', 'ALCOOL/GAS_NATURAL_COMBUSTIVEL', 'ALCOOL/GAS_NATURAL_VEICULAR', 'GAS_METANO', 'GAS_NATURAL_VEICULAR', 'GASOGENIO', 'DIESEL/GAS_NATURAL_VEICULAR', 'DIESEL/GAS_NATURAL_COMBUSTIVEL', 'GAS/NATURAL/LIQUEFEITO']
ELETRICO = ['ELETRICO/FONTE_EXTERNA', 'ELETRICO/FONTE_INTERNA', 'ELETRICO']
df18['Combustivel_Veiculo'] = df18['Combustivel_Veiculo'].apply(lambda x: 'HIBRIDO' if x in HIBRIDO else x)
df18['Combustivel_Veiculo'] = df18['Combustivel_Veiculo'].apply(lambda x: 'COMBUSTAO' if x in COMBUSTAO else x)
df18['Combustivel_Veiculo'] = df18['Combustivel_Veiculo'].apply(lambda x: 'ELETRICO' if x in ELETRICO else x)
print(df18['Combustivel_Veiculo'].unique())

# Para melhorar a visualizacao e evitar a repeticao dos nomes dos combustiveis, o agrupamento sera feito atraves do comando groupby() com somatoria dos valores
df18 = df18.groupby(['UF', 'Municipio', 'Combustivel_Veiculo']).sum().reset_index()

print(df18) 

'''Analise e plotagem de graficos - Crescimento Anual de 2020 a 2023'''

df20['Ano'] = 2020
df21['Ano'] = 2021
df22['Ano'] = 2022
df23['Ano'] = 2023

# Combinando os dataframes
df_combinados = pd.concat([df20, df21, df22, df23])

# Agrupamento por ano, tipo de combustivel e soma da quantidade de veiculos 
dados_anuais = df_combinados.groupby(['Ano', 'Combustivel_Veiculo'])['Qtd._Veiculos'].sum().reset_index()

# Filtrando somente por Hibridos e Eletricos
eletrificados_ano = dados_anuais[dados_anuais['Combustivel_Veiculo'].isin(['CELULA_COMBUSTIVEL','HIBRIDO', 'HIBRIDO_PLUG-IN', 'ELETRICO'])]

# Escolhendo o estilo/cor do grafico
sns.set(style="whitegrid")

# Criando grafico de linha
plt.figure(figsize=(10, 6))
sns.lineplot(data=eletrificados_ano, x='Ano', y='Qtd._Veiculos', hue='Combustivel_Veiculo', marker='o')

# Adicionando Titulos e legendas
plt.title("Crescimento de veiculos Eletrificados ao longo dos anos") #Titulo do grafico
plt.xlabel('Ano') #Nome do eixo X
plt.ylabel('Quantidade de Veiculos') #Nome do eixo Y 
plt.xticks(eletrificados_ano['Ano'].unique()) #Ticks no eixo 'Ano'
plt.legend(title='Tipo de Combustivel') #Legenda do grafico, representando o tipo de combustivel plotado pra cada linha
for x, y in zip(eletrificados_ano['Ano'], eletrificados_ano['Qtd._Veiculos']):
    plt.text(x, y, f'{int(y)}', verticalalignment='bottom', horizontalalignment='right') #Mostrar os valores de cada Ano x Qtd de Veiculos

# Mostrar grafico
plt.show()

'''Analise e plotagem de graficos - Total de Veiculos Eletrificados por Estado'''

# Filtrando veiculos eletrificados
eletrificados_2023 = df23[df23['Combustivel_Veiculo'].isin(['CELULA_COMBUSTIVEL','HIBRIDO', 'HIBRIDO_PLUG-IN', 'ELETRICO'])]

# Agregando por UF, alterando nomes para siglas dos estados para melhor visualizacao
eletrificados_estados = eletrificados_2023.groupby('UF')['Qtd._Veiculos'].sum().reset_index()
eletrificados_estados2 = eletrificados_estados.copy() # criando copia para alteracao de nomes na coluna UF
siglas_UF = {
    'ACRE': 'AC', 'ALAGOAS': 'AL', 'AMAPA': 'AP', 'AMAZONAS': 'AM', 'BAHIA': 'BA', 'CEARA': 'CE', 
    'DISTRITO_FEDERAL': 'DF', 'ESPIRITO_SANTO': 'ES', 'GOIAS': 'GO', 'MARANHAO': 'MA', 
    'MATO_GROSSO': 'MT', 'MATO_GROSSO_DO_SUL': 'MS', 'MINAS_GERAIS': 'MG', 'PARA': 'PA', 
    'PARAIBA': 'PB', 'PARANA': 'PR', 'PERNAMBUCO': 'PE', 'PIAUI': 'PI', 'RIO_DE_JANEIRO': 'RJ', 
    'RIO_GRANDE_DO_NORTE': 'RN', 'RIO_GRANDE_DO_SUL': 'RS', 'RONDONIA': 'RO', 'RORAIMA': 'RR', 
    'SANTA_CATARINA': 'SC', 'SAO_PAULO': 'SP', 'SERGIPE': 'SE', 'TOCANTINS': 'TO'
}  # trocando nomes dos estados por siglas
eletrificados_estados2['UF'] = eletrificados_estados2['UF'].map(siglas_UF).fillna(eletrificados_estados2['UF']) #incluindo no novo DF

# Escolhendo estilo/cor do grafico com o seaborn
sns.set(style="whitegrid")

# Criando grafico de barras
plt.figure(figsize=(12, 6))  #Ajute de tamanho
ax = sns.barplot(data=eletrificados_estados2, x='UF', y='Qtd._Veiculos', palette="Pastel2") #ajuste de layout e cores, cor Pastel2 

# Adiconando titulos de legendas
plt.title('Numero de Eletrificados em Julho de 2023 por estado')
plt.xlabel('Estado')
plt.ylabel('Quantidade')
for p in ax.patches:
    height = p.get_height()
    plt.text(p.get_x() + p.get_width() / 2., height + 3, f'{int(height)}', ha='center', va='bottom') #Posicionando legenda em cima das barras do grafico

# Mostrar grafico
plt.show()

'''Analise e plotagem de graficos - Relacao entre os tipos veiculos eletrificados'''

# Criando dicionario para armazenar os dados
dadosEV = {'Ano': [], 'CELULA_COMBUSTIVEL': [], 'HIBRIDO': [], 'HIBRIDO_PLUG_IN': [], 'ELETRICO': []}

for Ano, df in zip(range(2018, 2024), [df18, df19, df20, df21, df22, df23]):
    # Calcular a quantidade de veiculos por tipo
    cont_celula = df[df['Combustivel_Veiculo'] == 'CELULA_COMBUSTIVEL']['Qtd._Veiculos'].sum()
    cont_hibrido = df[df['Combustivel_Veiculo'] == 'HIBRIDO']['Qtd._Veiculos'].sum()
    cont_hibrido_plug_in = df[df['Combustivel_Veiculo'] == 'HIBRIDO_PLUG-IN']['Qtd._Veiculos'].sum()
    cont_eletrico = df[df['Combustivel_Veiculo'] == 'ELETRICO']['Qtd._Veiculos'].sum()

    # Armazenar os dados
    dadosEV['Ano'].append(Ano)
    dadosEV['CELULA_COMBUSTIVEL'].append(cont_celula)
    dadosEV['HIBRIDO'].append(cont_hibrido)
    dadosEV['HIBRIDO_PLUG_IN'].append(cont_hibrido_plug_in)
    dadosEV['ELETRICO'].append(cont_eletrico)

# Converter para DataFrame
df_comparacao = pd.DataFrame(dadosEV)

# Calcular o total de veículos eletrificados por ano
df_comparacao['Total'] = df_comparacao[['CELULA_COMBUSTIVEL', 'HIBRIDO', 'HIBRIDO_PLUG_IN', 'ELETRICO']].sum(axis=1)

# Calcular as proporções percentuais de cada tipo de veículo
df_comparacao['CELULA_COMBUSTIVEL_Pct'] = (df_comparacao['CELULA_COMBUSTIVEL'] / df_comparacao['Total']) * 100
df_comparacao['HIBRIDO_Pct'] = (df_comparacao['HIBRIDO'] / df_comparacao['Total']) * 100
df_comparacao['HIBRIDO_PLUG_IN_Pct'] = (df_comparacao['HIBRIDO_PLUG_IN'] / df_comparacao['Total']) * 100
df_comparacao['ELETRICO_Pct'] = (df_comparacao['ELETRICO'] / df_comparacao['Total']) * 100

# Plotando o gráfico de proporções
plt.figure(figsize=(12, 6))

# variavel para medir a posicao, pois sera um grafico de barras empilhado
bottom = [0] * len(df_comparacao) 
# definção da estetica do grafico
for col, color, label in zip(['CELULA_COMBUSTIVEL_Pct', 'HIBRIDO_Pct', 'HIBRIDO_PLUG_IN_Pct', 'ELETRICO_Pct'], 
                             ['blue', 'green', 'purple', 'orange'], 
                             ['Célula de Combustível', 'Híbrido', 'Híbrido Plug-In', 'Elétrico']):
    plt.bar(df_comparacao['Ano'], df_comparacao[col], bottom=bottom, color=color, label=label)
    
    # Adicionar texto nas barras
    for i in range(len(df_comparacao)):
        pct = df_comparacao[col].iloc[i]
        if pct > 0:  # Apenas mostrar se a porcentagem for maior que 0
            plt.text(df_comparacao['Ano'].iloc[i], bottom[i] + pct/2, f'{pct:.1f}%', ha='center', va='center')
    
    # Atualizar a posição do bottom para a próxima série
    bottom = [u + v for u, v in zip(bottom, df_comparacao[col])]

# Adicionando legendas e títulos
plt.xlabel('Ano')
plt.ylabel('Proporção (%)')
plt.title('Proporção entre Veículos Eletrificados (2018-2023)')
plt.legend()

# Mostrar o gráfico
plt.show()

'''Analise e plotagem de graficos - 10 Municipios do Brasil com mais veiculos eletrificados em Julho de 2023'''

# Filtrar o DataFrame para incluir apenas veículos eletrificados
df_eletrificados = df23[df23['Combustivel_Veiculo'].isin(['HIBRIDO', 'HIBRIDO_PLUG_IN', 'ELETRICO','CELULA_COMBUSTIVEL'])]

# Agrupar por município e somar a quantidade de veículos
soma_veiculos_por_municipio = df_eletrificados.groupby('Municipio')['Qtd._Veiculos'].sum().sort_values(ascending=False).head(10)

# Ordenar os municípios pela quantidade de veículos e selecionar os 10 primeiros
top_10_municipios = soma_veiculos_por_municipio.reset_index()

# Adicionando uma coluna 'ID', somente para usar no eixo x, já que os nomes dos municipios serao mostrados somente no quadro da legenda
top_10_municipios['ID'] = range(1, len(top_10_municipios) + 1)

# Selecao de tamanho e tipo de grafico com seaborn
sns.set(style="whitegrid")
plt.figure(figsize=(14, 6))
ax = sns.barplot(x='ID', y='Qtd._Veiculos', hue='Municipio', data=top_10_municipios) #plotando com quadro de legendas com os nomes dos municipios para melhor leitura

# Adicionando nomes das legendas
plt.title('Top 10 Municípios no Brasil com Maior Quantidade de Veículos Eletrificados em Julho de 2023')
plt.xlabel('Município')
plt.ylabel('Quantidade de Veículos')
plt.xticks([]) # Para fins esteticos do grafico, nomes dos munucipios foram ocultos no eixo x, devido ao tamanho longo do nome de alguns dificultar a visualizacao 
plt.legend(title='Município') # Adicionar quadro com legenda de nomes dos municipios 

# Adicionar as anotacoes das quantidades acima das barras
for p in ax.patches:
    ax.annotate(format(p.get_height(), '.0f'), 
                (p.get_x() + p.get_width() / 2., p.get_height()), 
                ha = 'center', va = 'center', 
                xytext = (0, 10), 
                textcoords = 'offset points')
    
plt.show() # Mostrar o grafico

'''PREPARACAO DOS DADOS - PREVISAO DE FROTA DE ELETRIFICADOS PARA OS PROXIMOS ANOS'''

# Concatenando os DataFrames de cada ano em um único DataFrame
df_total = pd.concat([df18, df19, df20, df21, df22, df23])

# Filtrar para veículos elétricos e híbridos e agrupar por ano
df_filtrado = df_total[df_total['Combustivel_Veiculo'].isin(['HIBRIDO', 'HIBRIDO_PLUG_IN', 'ELETRICO','CELULA_COMBUSTIVEL'])]
df_anual = df_filtrado.groupby('Ano')['Qtd._Veiculos'].sum()

'''SERIES TEMPORAIS - ARIMA - PREVISAO DE FROTA DE ELETRIFICADOS PARA OS PROXIMOS ANOS'''

from statsmodels.tsa.arima.model import ARIMA # Importando ARIMA 
from statsmodels.tsa.stattools import adfuller # Teste para verificar se os dados sao estacionarios 

# Ajustar o modelo ARIMA, parametros p, d, q escolhidos com valores baixos(1, 1, 1) para uma primeira abordagem
model = ARIMA(df_anual, order=(1, 1, 1))
model_fit = model.fit()

# Fazer previsões para os próximos 3 anos, 3 steps
previsoes = model_fit.forecast(steps=3)

# Plotar as previsões
plt.figure(figsize=(10, 6))
plt.plot(df_anual.index, df_anual, label='Dados Históricos')
plt.plot([2024, 2025, 2026], previsoes, label='Previsões ARIMA', color='red')
plt.title('Previsão de Veículos Elétricos e Híbridos para 2024, 2025 e 2026')
plt.xlabel('Ano')
plt.ylabel('Quantidade de Veículos')
plt.xticks(list(df_anual.index) + [2024, 2025, 2026])  # Adicionando anos nas previsões
# Adicionar rótulos com os valores numéricos
for year, value in zip(df_anual.index, df_anual):
    plt.text(year, value, f'{int(value)}', ha='center', va='bottom')
for year, value in zip([2024, 2025, 2026], previsoes):
    plt.text(year, value, f'{int(value)}', ha='center', va='bottom')
plt.legend()
plt.show()

# Avaliar o Modelo, considerado que df_anual seja a série temporal de dados históricos

# Definindo um tamanho de "janela" para walk-forward validation
window = 3  # Por exemplo, usar 3 anos para treinar e prever o próximo ano

# Listas para armazenar os resultados das métricas
mse_values = [] # Mean Squared Error
mae_values = [] # Mean Absolute Error

for i in range(window, len(df_anual)):
    train = df_anual.iloc[:i]
    test = df_anual.iloc[i:i+1]
    
    # Ajustar o modelo no conjunto de treino
    model = ARIMA(train, order=(1, 1, 1))
    model_fit = model.fit()
    
    # Prever o próximo ponto
    predictions = model_fit.forecast(steps=1)
    
    # Calcular e armazenar as métricas
    mse = mean_squared_error(test, predictions)
    mae = mean_absolute_error(test, predictions)
    mse_values.append(mse)
    mae_values.append(mae)

# Exibir a média das métricas
print(f"Média do MSE: {sum(mse_values) / len(mse_values)}") # 121706901.5165714
print(f"Média do MAE: {sum(mae_values) / len(mae_values)}") # 11032.085093787638
# 'Too few observations to estimate starting parameters%s'

# Função para realizar e imprimir os resultados do teste ADF
def testar_estacionariedade(serie):
    resultado_adf = adfuller(serie, autolag='AIC')
    print(f'Estatística ADF : {resultado_adf[0]}') # 31.668190766272982
    print(f'p-valor : {resultado_adf[1]}') # 1.0
    for key, value in resultado_adf[4].items():
        print(f'Valor Crítico {key} : {value}') 
        # Valor Crítico 1% : -10.41719074074074
        # Valor Crítico 5% : -5.77838074074074
        # Valor Crítico 10% : -3.391681111111111

# Aplicar o teste ADF na série temporal
testar_estacionariedade(df_anual)

# Estatística ADF = 31.67, é muito maior que qualquer um dos valores críticos
# p-valor =1, logo a série temporal provavelmente não é estacionária, realizar diferenciacao
'''
# Aplicar diferenciação
df_anual_diferenciada = df_anual.diff().dropna()  # Usando diff() para diferenciar e dropna() para remover valores vazios/NaNs que surgem após a diferenciacao

# Ajustar o modelo ARIMA com d=2
model_diferenciado = ARIMA(df_anual, order=(1, 1, 1))
model_fit_diferenciado = model_diferenciado.fit()

# Reexecutando o Teste ADF na série diferenciada
resultado_adf_diferenciado = adfuller(df_anual_diferenciada, autolag='AIC')
print(f'Estatística ADF após diferenciação: {resultado_adf_diferenciado[0]}')
print(f'p-valor após diferenciação: {resultado_adf_diferenciado[1]}')
for key, value in resultado_adf_diferenciado[4].items():
    print(f'Valor Crítico {key} após diferenciação: {value}')
'''
    # ValueError: sample size is too short to use selected regression component - Serie nao estacionaria, modelo inviavel após mais de uma diferenciacao










'''SARIMA  - PREVISAO DE FROTA DE ELETRIFICADOS PARA OS PROXIMOS ANOS'''

# Concatenando os DataFrames de cada ano em um único DataFrame
df_total = pd.concat([df18, df19, df20, df21, df22, df23])

# Filtrar para veículos elétricos e híbridos e agrupar por ano
df_filtrado = df_total[df_total['Combustivel_Veiculo'].isin(['HIBRIDO', 'HIBRIDO_PLUG_IN', 'ELETRICO','CELULA_COMBUSTIVEL'])]
df_anual = df_filtrado.groupby('Ano')['Qtd._Veiculos'].sum()

from statsmodels.tsa.statespace.sarimax import SARIMAX
from math import sqrt

# O SARIMA funciona bem com séries temporais que têm uma sazonalidade clara.

# Dividir os dados em conjunto de treino e teste 
train = df_anual.iloc[:-3]
test = df_anual.iloc[-3:]

# Definir os parâmetros do modelo SARIMA
# Os valores p, d, q são para a parte ARIMA do modelo
# Os valores P, D, Q, s são para a parte sazonal
# P = olha para o valor da série temporal em uma temporada anterior para ajudar a prever o valor atual.
# D = modelo aplica diferenciação sazonal
# (por exemplo, a mudança entre este mês e o mesmo mês do ano anterior).
# Q = modelo leva em conta quanto ele errou na última temporada ao fazer previsões para esta temporada.
# SARIMAX(df_anual, order=(1, 1, 1), seasonal_order=(1, 1, 1, 12)), s = 12, pois a sazonalidade é anual (12 meses)
sarima_model = SARIMAX(df_anual, order=(1, 1, 1), seasonal_order=(1, 0, 1, 12)) 
# como observado no ARIMA, devido ao volume de dados, a diferenciacao sazonal (D=0) nao foi aplicada
sarima_model_fit = sarima_model.fit()

# Previsoes
sarima_previsoes = sarima_model_fit.forecast(steps=len(test))

# Plotar as previsões junto com os dados históricos
plt.figure(figsize=(10, 6))
plt.plot(df_anual.index, df_anual, label='Dados Históricos')
plt.plot([2024, 2025, 2026], sarima_previsoes, label='Previsões SARIMA', color='red')
plt.title('Previsões com Modelo SARIMA')
plt.xlabel('Ano')
plt.ylabel('Quantidade de Veículos Elétricos e Híbridos')
plt.xticks(list(df_anual.index) + [2024, 2025, 2026])  # Adicionando anos nas previsões
# Adicionar rótulos com os valores numéricos
for year, value in zip(df_anual.index, df_anual):
    plt.text(year, value, f'{int(value)}', ha='center', va='bottom')
for year, value in zip([2024, 2025, 2026], sarima_previsoes):
    plt.text(year, value, f'{int(value)}', ha='center', va='bottom')
plt.legend()
plt.show()

# Etapa de validação cruzada
mse_scores = []

for t in range(1, len(df_anual) - 2):
    # Divisão em treino e teste
    train = df_anual.iloc[:t]
    test = df_anual.iloc[t:t+1]
    
    # Treinando o modelo
    model = SARIMAX(train, order=(1, 1, 1), seasonal_order=(1, 0, 1, 12))
    model_fit = model.fit(disp=False)
    
    # Previsão
    pred = model_fit.forecast(steps=len(test))
    
    # Calculando o MSE
    mse = mean_squared_error(test, pred)
    mse_scores.append(mse)

# Calculando a média dos erros
mean_mse = sum(mse_scores) / len(mse_scores)
rmse = sqrt(mean_mse)

print(f'Média do MSE: {mean_mse}')
print(f'RMSE: {rmse}')




# Too few observations to estimate starting parameters%s.
# Testar com tensorflow simples (x), depois com Regressão Linear, random forest ou gradient boosting regressor 



from fbprophet import Prophet

# Preparando os dados para o Prophet
df_prophet = pd.DataFrame({'ds': df_anual.index, 'y': df_anual.values})

# Inicializando e treinando o modelo Prophet
model_prophet = Prophet(yearly_seasonality=True, daily_seasonality=False)
model_prophet.fit(df_prophet)

# Criando um DataFrame futuro para previsões
future = model_prophet.make_future_dataframe(periods=3, freq='Y')

# Fazendo previsões
forecast = model_prophet.predict(future)

# Extraindo as previsões para 2024, 2025 e 2026
previsoes_prophet = forecast[forecast['ds'].dt.year >= 2024][['ds', 'yhat', 'yhat_lower', 'yhat_upper']]

# Plotando as previsões
fig1 = model_prophet.plot(forecast)







'''PREPARACAO DOS DADOS - CLASSIFICACAO QUATIDADE DE ELETRIFICADOS NOS ESTADOS COM MACHINE LEARNING'''

# Filtrando o DataFrame para veículos Eletrificados
df_eletricos_hibridos = df23[df23['Combustivel_Veiculo'].isin(['HIBRIDO', 'HIBRIDO_PLUG_IN', 'ELETRICO','CELULA_COMBUSTIVEL'])]

# Agrupando por UF e somando a quantidade de veículos
soma_veiculos_por_uf = df_eletricos_hibridos.groupby('UF')['Qtd._Veiculos'].sum()

# Convertendo a série em DataFrame
df_uf = soma_veiculos_por_uf.reset_index()

# Categorizando em faixas (baixa, média, alta)
df_uf['Categoria'] = pd.qcut(df_uf['Qtd._Veiculos'], 3, labels=['baixa', 'media', 'alta'])

# Codificando a variável categórica 'UF'
le_uf = LabelEncoder()
df_uf['UF_encoded'] = le_uf.fit_transform(df_uf['UF'])

# Codificando a variável alvo 'Categoria'
le_categoria = LabelEncoder()
df_uf['Categoria_encoded'] = le_categoria.fit_transform(df_uf['Categoria'])

# Divisão em Conjuntos de Treino e Teste
X = df_uf[['UF_encoded']]  # Características
y = df_uf['Categoria_encoded']  # Variável alvo codificada

'''MACHINE LEARNING - RANDOM FOREST'''

from sklearn.ensemble import RandomForestClassifier # Modelo Random Forest para classificacao

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

# Construir e Treinar o Modelo
model = RandomForestClassifier(n_estimators=100, random_state=42)
model.fit(X_train, y_train)

# Avaliar o modelo ccom report
y_pred = model.predict(X_test)
print(classification_report(y_test, y_pred)) # Accuracy = 0.44, 44% das previsões totais foram corretas

# Realizar previsões para todo o conjunto de dados
y_pred = model.predict(df_uf[['UF_encoded']])

# Converter as previsões de volta para os rótulos originais para impromir as classificacoes
df_uf['Predicao'] = le_categoria.inverse_transform(y_pred)

# Imprimir a classificação de cada UF
for uf, categoria in zip(df_uf['UF'], df_uf['Predicao']):
    print(f"UF: {uf}, Categoria Predita: {categoria}")

# Aplicar a validação cruzada
scores = cross_val_score(model, X, y, cv=5, scoring='accuracy')  # cv=5 para 5-fold
print("Acurácias da Validação Cruzada - Random Forest:", scores) # Imprimir validacao cruzada 5fold  [0.5 0.5 0.2 0.2 0.2]
print("Média das Acurácias - Random Forest:", scores.mean()) # Imprimir media das precisoes: 0.31999999999999995

'''MACHINE LEARNING - SUPPORT VECTOR MACHINE (SVM)'''

from sklearn.svm import SVC # Importando modelo Support Vector Machine

# Utilizando os dados ja preparados na primeira classificacao com Random Forest

# Normalizacao das caracteristicas
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)  # Normalizando as características

# Divisao dos Dados em Treino e Teste
X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.3, random_state=42)

# Construcao, ajuste de hiperparametros e treinamento do modelo SVM
svm_model = SVC(kernel='rbf', C=1, gamma='auto')  # RBF (Radial Basis Function) Kernel escolhido pois costuma funcionar para a maioria das aplicacoes
# Parâmetro de regularização C=1:  Valores maiores levam a menor regularização.
# gamma='auto': Coeficiente para o kernel RBF.
svm_model.fit(X_train, y_train) # treinamento

# Fazer previsões no conjunto de teste
y_pred = svm_model.predict(X_test)

# Avaliar o modelo
print(classification_report(y_test, y_pred)) # Accuracy = 0.44, 44% das previsões totais foram corretas

# Realizar previsões para todo o conjunto de dados
y_pred = svm_model.predict(X_scaled)

# Adicionar as previsões ao DataFrame
df_uf['Predicao'] = le_categoria.inverse_transform(y_pred)  # Certifique-se de que 'le_categoria' é o LabelEncoder para a variável alvo

# Imprimir a classificação de cada UF
for uf, categoria in zip(df_uf['UF'], df_uf['Predicao']):
    print(f"UF: {uf}, Categoria Predita: {categoria}")

# Etapa de validacao cruzada
svm_scores = cross_val_score(svm_model, X, y, cv=5, scoring='accuracy')
print("Acurácias da Validação Cruzada SVM:", svm_scores) # Imprimir validacao cruzada 5fold: [0.33333333  0.5  0.2  0.2  0.2]
print("Acurácia Média SVM:", svm_scores.mean()) # Imprimir media das precisoes: 0.2866666666666666

'''MACHINE LEARNING - K-Nearest Neighbors (KNN)'''

from sklearn.neighbors import KNeighborsClassifier # Importando Classificador KNN

# Utilizando os dados ja preparados na primeira classificacao com Random Forest

# Normalizar as características
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)  # Normalizando as características

# Divisao dos Dados em Treino e Teste
X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.3, random_state=42)

# Construcao e Treinamento do Modelo KNN
knn_model = KNeighborsClassifier(n_neighbors=5)
knn_model.fit(X_train, y_train)

# Fazer previsões no conjunto de teste
y_pred = knn_model.predict(X_test)

# Avaliar o modelo
print(classification_report(y_test, y_pred)) # Accuracy = 0.44, 44% das previsões totais foram corretas

# Realizar previsões para todo o conjunto de dados
y_pred = knn_model.predict(X_scaled)

# Adicionar as previsões ao DataFrame
df_uf['Predicao'] = le_categoria.inverse_transform(y_pred)

# Imprimir a classificação de cada UF
for uf, categoria in zip(df_uf['UF'], df_uf['Predicao']):
    print(f"UF: {uf}, Categoria Predita: {categoria}")

# Etapa de validacao cruzada
knn_scores = cross_val_score(knn_model, X, y, cv=5, scoring='accuracy')
print("Acurácias da Validação Cruzada KNN:", knn_scores) # Imprimir validacao cruzada 5fold: [0.5  0.33333333  0.2  0.4  0.2]
print("Acurácia Média KNN:", knn_scores.mean()) # Imprimir media das precisoes: 0.3266666666666666

'''MACHINE LEARNING - REDES NEURAIS - TENSORFLOW'''
'''
from tensorflow.keras.models import Sequential # Importando modelo Sequencial do Tensorflow, para rede neural simples e direta
from tensorflow.keras.layers import Dense # Camada densamente conectada
from tensorflow.keras.utils import to_categorical # converter vetores de inteiros em uma representação binária, classificacao dos estados em categorias destintas

# Utilizando os dados ja preparados na primeira classificacao com Random Forest

# Normalizar as características
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

# Converter a variável alvo para representação categórica
y_train_categorical = to_categorical(y_train)
y_test_categorical = to_categorical(y_test)

# Criar o modelo
tf_model = Sequential()
tf_model.add(Dense(10, input_dim=X_train_scaled.shape[1], activation='relu'))  # Camada de entrada
tf_model.add(Dense(10, activation='relu'))  # Camada oculta
tf_model.add(Dense(y_train_categorical.shape[1], activation='softmax'))  # Camada de saída

# Compilar o modelo com otimizador atualizado
tf_model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])

# Treinar o modelo
tf_model.fit(X_train_scaled, y_train_categorical, epochs=100, batch_size=10)

# Avaliar o modelo
loss, accuracy = tf_model.evaluate(X_test_scaled, y_test_categorical)
print(f"Acurácia: {accuracy}") # Acurácia: 0.2222222238779068

# Fazer previsões
#y_pred = tf_model.predict(X_test_scaled)

# Converter previsões para rótulos
#y_pred_labels = le_categoria.inverse_transform(y_pred.argmax(axis=1))

# Imprimir a classificação de cada UF
#for uf, pred in zip(le_uf.inverse_transform(X_test['UF_encoded']), y_pred_labels):
#    print(f"UF: {uf}, Categoria Predita: {pred}")
'''
