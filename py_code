import pandas as pd #biblioteca para manupulacao de dados
from unidecode import unidecode #edicao de caracteres
import matplotlib.pyplot as plt #plotagem de graficos
import seaborn as sns #biblioteca com base no matplotlib com melhor design para plotagem
import numpy as np #operacoes com array, validacoes cruzadas
from sklearn.preprocessing import StandardScaler # biblioteca para normalizacao de caracteristicas
from sklearn.model_selection import train_test_split # Biblioteca Scikit-learn para ML, teste e treinamento dos modelos
from sklearn.metrics import classification_report, accuracy_score # Biblioteca Scikit-learn para ML, avaliacao dos modelos
from sklearn.model_selection import cross_val_score # Biblioteca para realizar validacao cruzada nos modelos de ML
from sklearn.metrics import mean_squared_error, mean_absolute_error # Aplicação de metricas Mean Squared Error (MSE) e Mean Absolute Error (MAE)

'''Dados de Julho de 2023'''

#Ler arquivo .csv, gerando datafreame
df23 = pd.read_csv("d_frota_por_uf_municipio_combustivel_julho_2023.csv",
                         encoding = "UTF-8", sep = ";", usecols = ["UF",'Municipio',"Combustivel Veiculo","Qtd. Veiculos"])

print(df23.info()) #Qtd de entradas de dados = 47601
print(df23.head()) #Mostrar 5 primeiras linhas da tabela

#Substituir espacos (onde houver) dos titulos das colunas por "_"
df23.columns = df23.columns.str.replace(' ', '_')
print(df23.head())

print(df23['UF'].unique())
#Remover acentos e trocar espacos por "_" das linhas da coluna 'UF'
df23['UF'] = df23['UF'].apply(unidecode).str.replace(' ', '_')
#Deletar dados da coluna 'UF' sem identificacao de estados
df23 = df23[~df23['UF'].isin(['Nao_Identificado', 'Nao_se_Aplica', 'Sem_Informacao'])]
print(df23['UF'].unique())

print(df23['Combustivel_Veiculo'].unique())
#Remover acentos e trocar espa�os por "_" das linhas da coluna 'Combustivel_Veiculo'
df23['Combustivel_Veiculo'] = df23['Combustivel_Veiculo'].apply(unidecode).str.replace(' ', '_')
#Deletar dados da coluna 'Combustivel_Veiculo' sem identificacao de tipo de combustivel
df23 = df23[~df23['Combustivel_Veiculo'].isin(['Nao_Identificado', 'Sem_Informacao', 'VIDE/CAMPO/OBSERVACAO'])]
print(df23['Combustivel_Veiculo'].unique())

print(df23['Municipio'].unique())
#Remover acentos e trocar espacos por "_" das linhas da coluna 'Municipio'
df23['Municipio'] = df23['Municipio'].apply(unidecode).str.replace(' ', '_')
print(df23['Municipio'].unique())

#Reagrupamento de veiculos Hibridos Completos (HEV) e Hibridos Leves (MHEV), com excessao dos Hibridos Plugin (PHEV): HIBRIDO
#Veiculos Flex, Gasolina, Alcool, GNV, Diesel (nao eletrificados), serao reagrupados como "COMBUSTAO"
#Veiculos 100% eletricos (BEV) adicionados ao novo agrupamento: ELETRICO
HIBRIDO = ['GASOLINA/ALCOOL/ELETRICO', 'GASOLINA/ELETRICO', 'DIESEL/ELETRICO', 'HIBRIDO', 'ETANOL/ELETRICO']
COMBUSTAO = ['ALCOOL', 'ALCOOL/GASOLINA', 'DIESEL', 'GASOLINA', 'GASOLINA/ALCOOL/GAS_NATURAL', 'GASOL/GAS_NATURAL_COMBUSTIVEL', 'GASOLINA/GAS_NATURAL_VEICULAR', 'ALCOOL/GAS_NATURAL_COMBUSTIVEL', 'ALCOOL/GAS_NATURAL_VEICULAR', 'GAS_METANO', 'GAS_NATURAL_VEICULAR', 'GASOGENIO', 'DIESEL/GAS_NATURAL_VEICULAR', 'DIESEL/GAS_NATURAL_COMBUSTIVEL', 'GAS/NATURAL/LIQUEFEITO']
ELETRICO = ['ELETRICO/FONTE_EXTERNA', 'ELETRICO/FONTE_INTERNA', 'ELETRICO']
df23['Combustivel_Veiculo'] = df23['Combustivel_Veiculo'].apply(lambda x: 'HIBRIDO' if x in HIBRIDO else x)
df23['Combustivel_Veiculo'] = df23['Combustivel_Veiculo'].apply(lambda x: 'COMBUSTAO' if x in COMBUSTAO else x)
df23['Combustivel_Veiculo'] = df23['Combustivel_Veiculo'].apply(lambda x: 'ELETRICO' if x in ELETRICO else x)
print(df23['Combustivel_Veiculo'].unique())
#Para melhorar a visualizacao e evitar a repeticao dos nomes dos combustiveis, o agrupamento sera feito atraves do comando groupby() com somatoria dos valores
df23 = df23.groupby(['UF', 'Municipio', 'Combustivel_Veiculo']).sum().reset_index()

#df23.to_csv('df23_tratado.csv', index=False) #criar novo arquivo do dataframe
print(df23) 

''' Dados de Julho de 2022'''

df22 = pd.read_csv("d_frota_por_uf_municipio_combustivel_julho_2022.csv",
                         encoding = "UTF-8", sep = ";", usecols = ["UF",'Municipio',"Combustivel Veiculo","Qtd. Veiculos"])

# Substituir espacos (onde houver) dos titulos das colunas por "_"
df22.columns = df22.columns.str.replace(' ', '_')
# Tratamento das colunas: remocao de acentos, troca de espacos por "_" e filtragem de dados sem info
df22['UF'] = df22['UF'].apply(unidecode).str.replace(' ', '_')
df22 = df22[~df22['UF'].isin(['Nao_Identificado', 'Nao_se_Aplica', 'Sem_Informacao'])]

df22['Combustivel_Veiculo'] = df22['Combustivel_Veiculo'].apply(unidecode).str.replace(' ', '_')
df22 = df22[~df22['Combustivel_Veiculo'].isin(['Nao_Identificado', 'Sem_Informacao', 'VIDE/CAMPO/OBSERVACAO'])]

df22['Municipio'] = df22['Municipio'].apply(unidecode).str.replace(' ', '_')

# Reagrupamento de veiculos Hibridos(exceto PHEV), a Combustao e Eletricos
HIBRIDO = ['GASOLINA/ALCOOL/ELETRICO', 'GASOLINA/ELETRICO', 'DIESEL/ELETRICO', 'HIBRIDO', 'ETANOL/ELETRICO']
COMBUSTAO = ['ALCOOL', 'ALCOOL/GASOLINA', 'DIESEL', 'GASOLINA', 'GASOLINA/ALCOOL/GAS_NATURAL', 'GASOL/GAS_NATURAL_COMBUSTIVEL', 'GASOLINA/GAS_NATURAL_VEICULAR', 'ALCOOL/GAS_NATURAL_COMBUSTIVEL', 'ALCOOL/GAS_NATURAL_VEICULAR', 'GAS_METANO', 'GAS_NATURAL_VEICULAR', 'GASOGENIO', 'DIESEL/GAS_NATURAL_VEICULAR', 'DIESEL/GAS_NATURAL_COMBUSTIVEL', 'GAS/NATURAL/LIQUEFEITO']
ELETRICO = ['ELETRICO/FONTE_EXTERNA', 'ELETRICO/FONTE_INTERNA', 'ELETRICO']
df22['Combustivel_Veiculo'] = df22['Combustivel_Veiculo'].apply(lambda x: 'HIBRIDO' if x in HIBRIDO else x)
df22['Combustivel_Veiculo'] = df22['Combustivel_Veiculo'].apply(lambda x: 'COMBUSTAO' if x in COMBUSTAO else x)
df22['Combustivel_Veiculo'] = df22['Combustivel_Veiculo'].apply(lambda x: 'ELETRICO' if x in ELETRICO else x)
print(df22['Combustivel_Veiculo'].unique())
# Para melhorar a visualizacao e evitar a repeticao dos nomes dos combustiveis, o agrupamento sera feito atraves do comando groupby() com somatoria dos valores
df22 = df22.groupby(['UF', 'Municipio', 'Combustivel_Veiculo']).sum().reset_index()

print(df22) 

''' Dados de Julho de 2021'''

# Carregar os dados
df21 = pd.read_csv("d_frota_por_uf_municipio_combustivel_julho_2021.csv",
                   encoding="UTF-8", sep=";", usecols = ["UF",'Municipio',"Combustivel Veiculo","Qtd. Veiculos"])

# Substituir espacos (onde houver) dos titulos das colunas por "_"
df21.columns = df21.columns.str.replace(' ', '_')
# Tratamento das colunas: remocao de acentos, troca de espacos por "_" e filtragem de dados sem info
df21['UF'] = df21['UF'].apply(unidecode).str.replace(' ', '_')
df21 = df21[~df21['UF'].isin(['Nao_Identificado', 'Nao_se_Aplica', 'Sem_Informacao'])]

df21['Combustivel_Veiculo'] = df21['Combustivel_Veiculo'].apply(unidecode).str.replace(' ', '_')
df21 = df21[~df21['Combustivel_Veiculo'].isin(['Nao_Identificado', 'Sem_Informacao', 'VIDE/CAMPO/OBSERVACAO'])]

df21['Municipio'] = df21['Municipio'].apply(unidecode).str.replace(' ', '_')

# Reagrupamento de veiculos Hibridos, a Combustao e Eletricos
HIBRIDO = ['GASOLINA/ALCOOL/ELETRICO', 'GASOLINA/ELETRICO', 'DIESEL/ELETRICO', 'HIBRIDO', 'ETANOL/ELETRICO']
COMBUSTAO = ['ALCOOL', 'ALCOOL/GASOLINA', 'DIESEL', 'GASOLINA', 'GASOLINA/ALCOOL/GAS_NATURAL', 'GASOL/GAS_NATURAL_COMBUSTIVEL', 'GASOLINA/GAS_NATURAL_VEICULAR', 'ALCOOL/GAS_NATURAL_COMBUSTIVEL', 'ALCOOL/GAS_NATURAL_VEICULAR', 'GAS_METANO', 'GAS_NATURAL_VEICULAR', 'GASOGENIO', 'DIESEL/GAS_NATURAL_VEICULAR', 'DIESEL/GAS_NATURAL_COMBUSTIVEL', 'GAS/NATURAL/LIQUEFEITO']
ELETRICO = ['ELETRICO/FONTE_EXTERNA', 'ELETRICO/FONTE_INTERNA', 'ELETRICO']
df21['Combustivel_Veiculo'] = df21['Combustivel_Veiculo'].apply(lambda x: 'HIBRIDO' if x in HIBRIDO else x)
df21['Combustivel_Veiculo'] = df21['Combustivel_Veiculo'].apply(lambda x: 'COMBUSTAO' if x in COMBUSTAO else x)
df21['Combustivel_Veiculo'] = df21['Combustivel_Veiculo'].apply(lambda x: 'ELETRICO' if x in ELETRICO else x)
print(df21['Combustivel_Veiculo'].unique())

# Para melhorar a visualizacao e evitar a repeticao dos nomes dos combustiveis, o agrupamento sera feito atraves do comando groupby() com somatoria dos valores
df21 = df21.groupby(['UF', 'Municipio', 'Combustivel_Veiculo']).sum().reset_index()

print(df21)

'''Dados de Julho de 2020'''

df20 = pd.read_csv("d_frota_por_uf_municipio_combustivel_julho_2020.csv",
                   encoding="UTF-8", sep=";", usecols = ["UF",'Municipio',"Combustivel Veiculo","Qtd. Veiculos"])

# Substituir espacos dos titulos das colunas por "_"
df20.columns = df20.columns.str.replace(' ', '_')
# Tratamento das colunas: remocao de acentos, troca de espacos por "_" e filtragem de dados sem info
df20[['UF', 'Municipio', 'Combustivel_Veiculo']] = df20[['UF', 'Municipio', 'Combustivel_Veiculo']].applymap(unidecode).applymap(lambda x: x.replace(' ', '_'))
df20 = df20[~df20['UF'].isin(['Nao_Identificado', 'Nao_se_Aplica', 'Sem_Informacao'])]
df20 = df20[~df20['Combustivel_Veiculo'].isin(['Nao_Identificado', 'Sem_Informacao', 'VIDE/CAMPO/OBSERVACAO'])]

# Reagrupamento de veiculos Hibridos, a Combustao e Eletricos
df20['Combustivel_Veiculo'] = df20['Combustivel_Veiculo'].apply(lambda x: 'HIBRIDO' if x in HIBRIDO else x)
df20['Combustivel_Veiculo'] = df20['Combustivel_Veiculo'].apply(lambda x: 'COMBUSTAO' if x in COMBUSTAO else x)
df20['Combustivel_Veiculo'] = df20['Combustivel_Veiculo'].apply(lambda x: 'ELETRICO' if x in ELETRICO else x)
print(df20['Combustivel_Veiculo'].unique())

# Agrupamento atraves do comando groupby() com somatoria dos valores
df20 = df20.groupby(['UF', 'Municipio', 'Combustivel_Veiculo']).sum().reset_index()

print(df20)

'''Dados de Julho de 2019'''

df19 = pd.read_csv("d_frota_por_uf_municipio_combustivel_julho_2019.csv",
                   encoding="UTF-8", sep=";", usecols = ["UF",'Municipio',"Combustivel Veiculo","Qtd. Veiculos"])

# Substituir espacos dos titulos das colunas por "_"
df19.columns = df19.columns.str.replace(' ', '_')
# Tratamento das colunas: remocao de acentos, troca de espacos por "_" e filtragem de dados sem info
df19[['UF', 'Municipio', 'Combustivel_Veiculo']] = df19[['UF', 'Municipio', 'Combustivel_Veiculo']].applymap(unidecode).applymap(lambda x: x.replace(' ', '_'))
df19 = df19[~df19['UF'].isin(['Nao_Identificado', 'Nao_se_Aplica', 'Sem_Informacao'])]
df19 = df19[~df19['Combustivel_Veiculo'].isin(['VIDE/CAMPO/OBSERVACAO', 'NAPSo_se_Aplica', 'NAPSo_Identificado', 'Sem_InformaASSAPSo'])]

# Reagrupamento de veiculos Hibridos, a Combustao e Eletricos
HIBRIDO = ['GASOLINA/ALCOOL/ELETRICO', 'GASOLINA/ELETRICO', 'DIESEL/ELETRICO', 'HIBRIDO', 'ETANOL/ELETRICO']
COMBUSTAO = ['ALCOOL', 'ALCOOL/GASOLINA', 'DIESEL', 'GASOLINA', 'GASOLINA/ALCOOL/GAS_NATURAL', 'GASOL/GAS_NATURAL_COMBUSTIVEL', 'GASOLINA/GAS_NATURAL_VEICULAR', 'ALCOOL/GAS_NATURAL_COMBUSTIVEL', 'ALCOOL/GAS_NATURAL_VEICULAR', 'GAS_METANO', 'GAS_NATURAL_VEICULAR', 'GASOGENIO', 'DIESEL/GAS_NATURAL_VEICULAR', 'DIESEL/GAS_NATURAL_COMBUSTIVEL', 'GAS/NATURAL/LIQUEFEITO']
ELETRICO = ['ELETRICO/FONTE_EXTERNA', 'ELETRICO/FONTE_INTERNA', 'ELETRICO']

df19['Combustivel_Veiculo'] = df19['Combustivel_Veiculo'].apply(lambda x: 'HIBRIDO' if x in HIBRIDO else x)
df19['Combustivel_Veiculo'] = df19['Combustivel_Veiculo'].apply(lambda x: 'COMBUSTAO' if x in COMBUSTAO else x)
df19['Combustivel_Veiculo'] = df19['Combustivel_Veiculo'].apply(lambda x: 'ELETRICO' if x in ELETRICO else x)
print(df19['Combustivel_Veiculo'].unique())

# Agrupamento atraves do comando groupby() com somatoria dos valores
df19 = df19.groupby(['UF', 'Municipio', 'Combustivel_Veiculo']).sum().reset_index()

print(df19)

'''Dados de Julho de 2018'''

import pandas as pd
from unidecode import unidecode

''' Dados de Julho de 2018'''

# Carregar os dados
df18 = pd.read_csv("d_frota_por_uf_municipio_combustivel_julho_2018.csv",
                   encoding="UTF-8", sep=";", usecols=["UF", 'Municipio', "Combustivel Veiculo", "Qtd. Veiculos"])

# Substituir espacos (onde houver) dos titulos das colunas por "_"
df18.columns = df18.columns.str.replace(' ', '_')

# Tratamento das colunas: remocao de acentos, troca de espacos por "_" e filtragem de dados sem info
df18[['UF', 'Municipio', 'Combustivel_Veiculo']] = df18[['UF', 'Municipio', 'Combustivel_Veiculo']].applymap(unidecode).applymap(lambda x: x.replace(' ', '_'))
df18 = df18[~df18['UF'].isin(['Nao_Identificado', 'Nao_se_Aplica', 'Sem_Informacao'])]
df18 = df18[~df18['Combustivel_Veiculo'].isin(['VIDE/CAMPO/OBSERVACAO', 'NAPSo_se_Aplica', 'NAPSo_Identificado', 'Sem_InformaASSAPSo'])]

# Reagrupamento de veiculos Hibridos(exceto PHEV), a Combustao e Eletricos
HIBRIDO = ['GASOLINA/ALCOOL/ELETRICO', 'GASOLINA/ELETRICO', 'DIESEL/ELETRICO', 'HIBRIDO', 'ETANOL/ELETRICO']
COMBUSTAO = ['ALCOOL', 'ALCOOL/GASOLINA', 'DIESEL', 'GASOLINA', 'GASOLINA/ALCOOL/GAS_NATURAL', 'GASOL/GAS_NATURAL_COMBUSTIVEL', 'GASOLINA/GAS_NATURAL_VEICULAR', 'ALCOOL/GAS_NATURAL_COMBUSTIVEL', 'ALCOOL/GAS_NATURAL_VEICULAR', 'GAS_METANO', 'GAS_NATURAL_VEICULAR', 'GASOGENIO', 'DIESEL/GAS_NATURAL_VEICULAR', 'DIESEL/GAS_NATURAL_COMBUSTIVEL', 'GAS/NATURAL/LIQUEFEITO']
ELETRICO = ['ELETRICO/FONTE_EXTERNA', 'ELETRICO/FONTE_INTERNA', 'ELETRICO']
df18['Combustivel_Veiculo'] = df18['Combustivel_Veiculo'].apply(lambda x: 'HIBRIDO' if x in HIBRIDO else x)
df18['Combustivel_Veiculo'] = df18['Combustivel_Veiculo'].apply(lambda x: 'COMBUSTAO' if x in COMBUSTAO else x)
df18['Combustivel_Veiculo'] = df18['Combustivel_Veiculo'].apply(lambda x: 'ELETRICO' if x in ELETRICO else x)
print(df18['Combustivel_Veiculo'].unique())

# Para melhorar a visualizacao e evitar a repeticao dos nomes dos combustiveis, o agrupamento sera feito atraves do comando groupby() com somatoria dos valores
df18 = df18.groupby(['UF', 'Municipio', 'Combustivel_Veiculo']).sum().reset_index()

print(df18) 

'''Analise e plotagem de graficos - Crescimento Anual de 2020 a 2023'''

df20['Ano'] = 2020
df21['Ano'] = 2021
df22['Ano'] = 2022
df23['Ano'] = 2023

# Combinando os dataframes
df_combinados = pd.concat([df20, df21, df22, df23])

# Agrupamento por ano, tipo de combustivel e soma da quantidade de veiculos 
dados_anuais = df_combinados.groupby(['Ano', 'Combustivel_Veiculo'])['Qtd._Veiculos'].sum().reset_index()

# Filtrando somente por Hibridos e Eletricos
eletrificados_ano = dados_anuais[dados_anuais['Combustivel_Veiculo'].isin(['CELULA_COMBUSTIVEL','HIBRIDO', 'HIBRIDO_PLUG-IN', 'ELETRICO'])]

# Escolhendo o estilo/cor do grafico
sns.set(style="whitegrid")

# Criando grafico de linha
plt.figure(figsize=(10, 6))
sns.lineplot(data=eletrificados_ano, x='Ano', y='Qtd._Veiculos', hue='Combustivel_Veiculo', marker='o')

# Adicionando Titulos e legendas
plt.title("Crescimento de veiculos Eletrificados ao longo dos anos") #Titulo do grafico
plt.xlabel('Ano') #Nome do eixo X
plt.ylabel('Quantidade de Veiculos') #Nome do eixo Y 
plt.xticks(eletrificados_ano['Ano'].unique()) #Ticks no eixo 'Ano'
plt.legend(title='Tipo de Combustivel') #Legenda do grafico, representando o tipo de combustivel plotado pra cada linha
for x, y in zip(eletrificados_ano['Ano'], eletrificados_ano['Qtd._Veiculos']):
    plt.text(x, y, f'{int(y)}', verticalalignment='bottom', horizontalalignment='right') #Mostrar os valores de cada Ano x Qtd de Veiculos

# Mostrar grafico
plt.show()

'''Analise e plotagem de graficos - Total de Veiculos Eletrificados por Estado'''

# Filtrando veiculos eletrificados
eletrificados_2023 = df23[df23['Combustivel_Veiculo'].isin(['CELULA_COMBUSTIVEL','HIBRIDO', 'HIBRIDO_PLUG-IN', 'ELETRICO'])]

# Agregando por UF, alterando nomes para siglas dos estados para melhor visualizacao
eletrificados_estados = eletrificados_2023.groupby('UF')['Qtd._Veiculos'].sum().reset_index()
eletrificados_estados2 = eletrificados_estados.copy() # criando copia para alteracao de nomes na coluna UF
siglas_UF = {
    'ACRE': 'AC', 'ALAGOAS': 'AL', 'AMAPA': 'AP', 'AMAZONAS': 'AM', 'BAHIA': 'BA', 'CEARA': 'CE', 
    'DISTRITO_FEDERAL': 'DF', 'ESPIRITO_SANTO': 'ES', 'GOIAS': 'GO', 'MARANHAO': 'MA', 
    'MATO_GROSSO': 'MT', 'MATO_GROSSO_DO_SUL': 'MS', 'MINAS_GERAIS': 'MG', 'PARA': 'PA', 
    'PARAIBA': 'PB', 'PARANA': 'PR', 'PERNAMBUCO': 'PE', 'PIAUI': 'PI', 'RIO_DE_JANEIRO': 'RJ', 
    'RIO_GRANDE_DO_NORTE': 'RN', 'RIO_GRANDE_DO_SUL': 'RS', 'RONDONIA': 'RO', 'RORAIMA': 'RR', 
    'SANTA_CATARINA': 'SC', 'SAO_PAULO': 'SP', 'SERGIPE': 'SE', 'TOCANTINS': 'TO'
}  # trocando nomes dos estados por siglas
eletrificados_estados2['UF'] = eletrificados_estados2['UF'].map(siglas_UF).fillna(eletrificados_estados2['UF']) #incluindo no novo DF

# Escolhendo estilo/cor do grafico com o seaborn
sns.set(style="whitegrid")

# Criando grafico de barras
plt.figure(figsize=(12, 6))  #Ajute de tamanho
ax = sns.barplot(data=eletrificados_estados2, x='UF', y='Qtd._Veiculos', palette="Pastel2") #ajuste de layout e cores, cor Pastel2 

# Adiconando titulos de legendas
plt.title('Numero de Eletrificados em Julho de 2023 por estado')
plt.xlabel('Estado')
plt.ylabel('Quantidade')
for p in ax.patches:
    height = p.get_height()
    plt.text(p.get_x() + p.get_width() / 2., height + 3, f'{int(height)}', ha='center', va='bottom') #Posicionando legenda em cima das barras do grafico

# Mostrar grafico
plt.show()

'''Analise e plotagem de graficos - Relacao entre os tipos veiculos eletrificados'''

# Criando dicionario para armazenar os dados
dadosEV = {'Ano': [], 'CELULA_COMBUSTIVEL': [], 'HIBRIDO': [], 'HIBRIDO_PLUG_IN': [], 'ELETRICO': []}

for Ano, df in zip(range(2018, 2024), [df18, df19, df20, df21, df22, df23]):
    # Calcular a quantidade de veiculos por tipo
    cont_celula = df[df['Combustivel_Veiculo'] == 'CELULA_COMBUSTIVEL']['Qtd._Veiculos'].sum()
    cont_hibrido = df[df['Combustivel_Veiculo'] == 'HIBRIDO']['Qtd._Veiculos'].sum()
    cont_hibrido_plug_in = df[df['Combustivel_Veiculo'] == 'HIBRIDO_PLUG-IN']['Qtd._Veiculos'].sum()
    cont_eletrico = df[df['Combustivel_Veiculo'] == 'ELETRICO']['Qtd._Veiculos'].sum()

    # Armazenar os dados
    dadosEV['Ano'].append(Ano)
    dadosEV['CELULA_COMBUSTIVEL'].append(cont_celula)
    dadosEV['HIBRIDO'].append(cont_hibrido)
    dadosEV['HIBRIDO_PLUG_IN'].append(cont_hibrido_plug_in)
    dadosEV['ELETRICO'].append(cont_eletrico)

# Converter para DataFrame
df_comparacao = pd.DataFrame(dadosEV)

# Calcular o total de veículos eletrificados por ano
df_comparacao['Total'] = df_comparacao[['CELULA_COMBUSTIVEL', 'HIBRIDO', 'HIBRIDO_PLUG_IN', 'ELETRICO']].sum(axis=1)

# Calcular as proporções percentuais de cada tipo de veículo
df_comparacao['CELULA_COMBUSTIVEL_Pct'] = (df_comparacao['CELULA_COMBUSTIVEL'] / df_comparacao['Total']) * 100
df_comparacao['HIBRIDO_Pct'] = (df_comparacao['HIBRIDO'] / df_comparacao['Total']) * 100
df_comparacao['HIBRIDO_PLUG_IN_Pct'] = (df_comparacao['HIBRIDO_PLUG_IN'] / df_comparacao['Total']) * 100
df_comparacao['ELETRICO_Pct'] = (df_comparacao['ELETRICO'] / df_comparacao['Total']) * 100

# Plotando o gráfico de proporções
plt.figure(figsize=(12, 6))

# variavel para medir a posicao, pois sera um grafico de barras empilhado
bottom = [0] * len(df_comparacao) 
# definção da estetica do grafico
for col, color, label in zip(['CELULA_COMBUSTIVEL_Pct', 'HIBRIDO_Pct', 'HIBRIDO_PLUG_IN_Pct', 'ELETRICO_Pct'], 
                             ['blue', 'green', 'purple', 'orange'], 
                             ['Célula de Combustível', 'Híbrido', 'Híbrido Plug-In', 'Elétrico']):
    plt.bar(df_comparacao['Ano'], df_comparacao[col], bottom=bottom, color=color, label=label)
    
    # Adicionar texto nas barras
    for i in range(len(df_comparacao)):
        pct = df_comparacao[col].iloc[i]
        if pct > 0:  # Apenas mostrar se a porcentagem for maior que 0
            plt.text(df_comparacao['Ano'].iloc[i], bottom[i] + pct/2, f'{pct:.1f}%', ha='center', va='center')
    
    # Atualizar a posição do bottom para a próxima série
    bottom = [u + v for u, v in zip(bottom, df_comparacao[col])]

# Adicionando legendas e títulos
plt.xlabel('Ano')
plt.ylabel('Proporção (%)')
plt.title('Proporção entre Veículos Eletrificados (2018-2023)')
plt.legend()

# Mostrar o gráfico
plt.show()

'''PREPARACAO DOS DADOS - CLASSIFICACAO QUATIDADE DE HIBRIDOS E ELETRICOS NOS ESTADOS'''

from sklearn.preprocessing import LabelEncoder # biblioteca para converter rotulos das categorias em rotulos numericos

# Filtrando o DataFrame para veículos elétricos e híbridos
df_eletricos_hibridos = df23[df23['Combustivel_Veiculo'].isin(['ELETRICO', 'HIBRIDO'])]

# Agrupando por UF e somando a quantidade de veículos
soma_veiculos_por_uf = df_eletricos_hibridos.groupby('UF')['Qtd._Veiculos'].sum()

# Convertendo a série em DataFrame
df_uf = soma_veiculos_por_uf.reset_index()

# Categorizando em faixas (baixa, média, alta)
df_uf['Categoria'] = pd.qcut(df_uf['Qtd._Veiculos'], 3, labels=['baixa', 'media', 'alta'])

# Codificando a variável categórica 'UF'
le_uf = LabelEncoder()
df_uf['UF_encoded'] = le_uf.fit_transform(df_uf['UF'])

# Codificando a variável alvo 'Categoria'
le_categoria = LabelEncoder()
df_uf['Categoria_encoded'] = le_categoria.fit_transform(df_uf['Categoria'])

# Divisão em Conjuntos de Treino e Teste
X = df_uf[['UF_encoded']]  # Características
y = df_uf['Categoria_encoded']  # Variável alvo codificada

'''MACHINE LEARNING - RANDOM FOREST'''

from sklearn.ensemble import RandomForestClassifier # Modelo Random Forest para classificacao

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

# Construir e Treinar o Modelo
model = RandomForestClassifier(n_estimators=100, random_state=42)
model.fit(X_train, y_train)

# Avaliar o modelo ccom report
y_pred = model.predict(X_test)
print(classification_report(y_test, y_pred)) # Accuracy = 0.44, 44% das previsões totais foram corretas

# Realizar previsões para todo o conjunto de dados
y_pred = model.predict(df_uf[['UF_encoded']])

# Converter as previsões de volta para os rótulos originais para impromir as classificacoes
df_uf['Predicao'] = le_categoria.inverse_transform(y_pred)

# Imprimir a classificação de cada UF
for uf, categoria in zip(df_uf['UF'], df_uf['Predicao']):
    print(f"UF: {uf}, Categoria Predita: {categoria}")

# Aplicar a validação cruzada
scores = cross_val_score(model, X, y, cv=5, scoring='accuracy')  # cv=5 para 5-fold
print("Acurácias da Validação Cruzada - Random Forest:", scores) # Imprimir validacao cruzada 5fold  [0.5 0.5 0.2 0.2 0.2]
print("Média das Acurácias - Random Forest:", scores.mean()) # Imprimir media das precisoes: 0.31999999999999995

'''MACHINE LEARNING - SUPPORT VECTOR MACHINE (SVM)'''

from sklearn.svm import SVC # Importando modelo Support Vector Machine

# Utilizando os dados ja preparados na primeira classificacao com Random Forest

# Normalizacao das caracteristicas
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)  # Normalizando as características

# Divisao dos Dados em Treino e Teste
X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.3, random_state=42)

# Construcao, ajuste de hiperparametros e treinamento do modelo SVM
svm_model = SVC(kernel='rbf', C=1, gamma='auto')  # RBF (Radial Basis Function) Kernel escolhido pois costuma funcionar para a maioria das aplicacoes
# Parâmetro de regularização C=1:  Valores maiores levam a menor regularização.
# gamma='auto': Coeficiente para o kernel RBF.
svm_model.fit(X_train, y_train) # treinamento

# Fazer previsões no conjunto de teste
y_pred = svm_model.predict(X_test)

# Avaliar o modelo
print(classification_report(y_test, y_pred)) # Accuracy = 0.44, 44% das previsões totais foram corretas

# Realizar previsões para todo o conjunto de dados
y_pred = svm_model.predict(X_scaled)

# Adicionar as previsões ao DataFrame
df_uf['Predicao'] = le_categoria.inverse_transform(y_pred)  # Certifique-se de que 'le_categoria' é o LabelEncoder para a variável alvo

# Imprimir a classificação de cada UF
for uf, categoria in zip(df_uf['UF'], df_uf['Predicao']):
    print(f"UF: {uf}, Categoria Predita: {categoria}")

# Etapa de validacao cruzada
svm_scores = cross_val_score(svm_model, X, y, cv=5, scoring='accuracy')
print("Acurácias da Validação Cruzada SVM:", svm_scores) # Imprimir validacao cruzada 5fold: [0.33333333  0.5  0.2  0.2  0.2]
print("Acurácia Média SVM:", svm_scores.mean()) # Imprimir media das precisoes: 0.2866666666666666

'''MACHINE LEARNING - K-Nearest Neighbors (KNN)'''

from sklearn.neighbors import KNeighborsClassifier # Importando Classificador KNN

# Utilizando os dados ja preparados na primeira classificacao com Random Forest

# Normalizar as características
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)  # Normalizando as características

# Divisao dos Dados em Treino e Teste
X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.3, random_state=42)

# Construcao e Treinamento do Modelo KNN
knn_model = KNeighborsClassifier(n_neighbors=5)
knn_model.fit(X_train, y_train)

# Fazer previsões no conjunto de teste
y_pred = knn_model.predict(X_test)

# Avaliar o modelo
print(classification_report(y_test, y_pred)) # Accuracy = 0.44, 44% das previsões totais foram corretas

# Realizar previsões para todo o conjunto de dados
y_pred = knn_model.predict(X_scaled)

# Adicionar as previsões ao DataFrame
df_uf['Predicao'] = le_categoria.inverse_transform(y_pred)

# Imprimir a classificação de cada UF
for uf, categoria in zip(df_uf['UF'], df_uf['Predicao']):
    print(f"UF: {uf}, Categoria Predita: {categoria}")

# Etapa de validacao cruzada
knn_scores = cross_val_score(knn_model, X, y, cv=5, scoring='accuracy')
print("Acurácias da Validação Cruzada KNN:", knn_scores) # Imprimir validacao cruzada 5fold: [0.5  0.33333333  0.2  0.4  0.2]
print("Acurácia Média KNN:", knn_scores.mean()) # Imprimir media das precisoes: 0.3266666666666666

'''MACHINE LEARNING - REDES NEURAIS - TENSORFLOW'''

from tensorflow.keras.models import Sequential # Importando modelo Sequencial do Tensorflow, para rede neural simples e direta
from tensorflow.keras.layers import Dense # Camada densamente conectada
from tensorflow.keras.utils import to_categorical # converter vetores de inteiros em uma representação binária, classificacao dos estados em categorias destintas

# Utilizando os dados ja preparados na primeira classificacao com Random Forest

# Normalizar as características
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

# Converter a variável alvo para representação categórica
y_train_categorical = to_categorical(y_train)
y_test_categorical = to_categorical(y_test)

# Criar o modelo
tf_model = Sequential()
tf_model.add(Dense(10, input_dim=X_train_scaled.shape[1], activation='relu'))  # Camada de entrada
tf_model.add(Dense(10, activation='relu'))  # Camada oculta
tf_model.add(Dense(y_train_categorical.shape[1], activation='softmax'))  # Camada de saída

# Compilar o modelo com otimizador atualizado
tf_model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])

# Treinar o modelo
tf_model.fit(X_train_scaled, y_train_categorical, epochs=100, batch_size=10)

# Avaliar o modelo
loss, accuracy = tf_model.evaluate(X_test_scaled, y_test_categorical)
print(f"Acurácia: {accuracy}") # Acurácia: 0.2222222238779068

# Fazer previsões
#y_pred = tf_model.predict(X_test_scaled)

# Converter previsões para rótulos
#y_pred_labels = le_categoria.inverse_transform(y_pred.argmax(axis=1))

# Imprimir a classificação de cada UF
#for uf, pred in zip(le_uf.inverse_transform(X_test['UF_encoded']), y_pred_labels):
#    print(f"UF: {uf}, Categoria Predita: {pred}")
